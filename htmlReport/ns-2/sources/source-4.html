


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CustomerController</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.mygdx.game.Core</a>
</div>

<h1>Coverage Summary for Class: CustomerController (com.mygdx.game.Core)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CustomerController</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (27/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64%
  </span>
  <span class="absValue">
    (181/283)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.mygdx.game.Core;
&nbsp;
&nbsp;import com.badlogic.gdx.Gdx;
&nbsp;import com.badlogic.gdx.Input.Keys;
&nbsp;import com.badlogic.gdx.graphics.g2d.TextureAtlas;
&nbsp;import com.mygdx.game.Core.Customers.CustomerGroups;
&nbsp;import com.mygdx.game.Core.Customers.OrderMenu;
&nbsp;import com.mygdx.game.Core.Customers.Randomisation;
&nbsp;import com.mygdx.game.Core.Customers.Table;
&nbsp;import com.mygdx.game.Core.GameState.CustomerGroupState;
&nbsp;import com.mygdx.game.Core.GameState.GameState;
&nbsp;import com.mygdx.game.Core.ValueStructures.CustomerControllerParams;
&nbsp;import com.mygdx.game.Core.ValueStructures.EndOfGameValues;
&nbsp;import com.mygdx.game.Customer;
&nbsp;import com.mygdx.game.Items.Item;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import com.badlogic.gdx.math.Vector2;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Random;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;/*
&nbsp;  This script controls the customers and handles their logic through a variety of secondary scripts.
&nbsp;  Also handles when the current game should end.
&nbsp;
&nbsp;  Last modified: 23/04/2023
&nbsp; */
&nbsp;
&nbsp;public class CustomerController extends Scriptable
&nbsp;{
&nbsp;
&nbsp;  /**The current customer group waiting in line*/
<b class="fc">&nbsp;  CustomerGroups currentWaiting = null;</b>
&nbsp;
&nbsp;  /**List of customers sitting down and eating. Groups only enter this when all members are eating*/
<b class="fc">&nbsp;  List&lt;CustomerGroups&gt; SittingCustomers = new LinkedList&lt;&gt;();</b>
&nbsp;  /**List of all customer groups trying to leave*/
<b class="fc">&nbsp;  List&lt;CustomerGroups&gt; WalkingBackCustomers = new LinkedList&lt;&gt;();</b>
&nbsp;  /**Pathfinding module used*/
&nbsp;  Pathfinding pathfinding;
&nbsp;
&nbsp;  /**
&nbsp;   * List of tables
&nbsp;   */
&nbsp;  List&lt;Table&gt; tables;
&nbsp;  /** Call this to start endge game sequence */
&nbsp;  Consumer&lt;EndOfGameValues&gt; CallEndGame;
&nbsp;
&nbsp;  public int Reputation;
&nbsp;  public int Money;
&nbsp;  int MaxMoney;
&nbsp;  int MaxReputation;
&nbsp;  int MoneyPerCustomer;
&nbsp;
<b class="fc">&nbsp;  int Waves = -1;</b>
&nbsp;  OrderMenu menu;
<b class="fc">&nbsp;  int currentCustomer = 0;</b>
<b class="fc">&nbsp;  int currentWave = 0;</b>
<b class="fc">&nbsp;  private float EatingTime = 7;</b>
<b class="fc">&nbsp;  private int TimerWidth = 50;</b>
<b class="fc">&nbsp;  private int TimerHeight = 10;</b>
&nbsp;
&nbsp;  /** Frustration Time*/
&nbsp;  private GameObject FrustrationTimer;
&nbsp;  private GameObject FrustrationTimerBackground;
&nbsp;
&nbsp;  /** Creates a new randomisation class based on the current time */
<b class="fc">&nbsp;  Random rand = new Random(System.currentTimeMillis());</b>
&nbsp;
&nbsp;  /** The minimum and maximum group size for customers groups */
<b class="fc">&nbsp;  private Vector2 groupSize = new Vector2(1,4);</b>
&nbsp;
&nbsp;  /** timer defining when the next eating customer will leave */
<b class="fc">&nbsp;  float NextToLeave = EatingTime;</b>
&nbsp;  int MaxCustomers;
&nbsp;  int CustomersRemaining;
&nbsp;  ArrayList&lt;Integer&gt; customersPerWave;
&nbsp;/** this is call back for customer groups who get too frustrated so they need to leave */
&nbsp;  Consumer&lt;CustomerGroups&gt; FrustrationCallBack;
&nbsp;
&nbsp;  /** Door position */
&nbsp;  Vector2 DoorTarget;
&nbsp;  /** where ordering queue should start */
&nbsp;  Vector2 OrderAreaTarget;
&nbsp;
&nbsp;  /**
&nbsp;   * All customer texture atlases
&nbsp;   */
<b class="fc">&nbsp;  private ArrayList&lt;TextureAtlas&gt; CustomerAtlas = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;  /** how long it takes for a group to be frustrated and leave without being served*/
<b class="fc">&nbsp;  private int CustomerFrustrationStart = 80;</b>
&nbsp;
<b class="fc">&nbsp;  boolean updateFrustration = true;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Creates the customer controller
&nbsp;   * @param DoorPosition Customer spawn and exit.
&nbsp;   * @param OrderArea First position in order line
&nbsp;   * @param path    Pathfinding Module.
&nbsp;   * @param CallUpGameFinish Game Finish Function.
&nbsp;   * @param params Parameter class
&nbsp;   * @param TablePositions Where the tables are, TEMPORARY
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public CustomerController(Vector2 DoorPosition, Vector2 OrderArea, Pathfinding path,
<b class="fc">&nbsp;      Consumer&lt;EndOfGameValues&gt; CallUpGameFinish, CustomerControllerParams params, Vector2... TablePositions){</b>
<b class="fc">&nbsp;    tables = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    FrustrationCallBack = (CustomerGroups a)   -&gt; FrustrationLeave(a);</b>
<b class="fc">&nbsp;    MoneyPerCustomer = params.MoneyPerCustomer;</b>
<b class="fc">&nbsp;    CallEndGame = CallUpGameFinish;</b>
<b class="fc">&nbsp;    Money = params.MoneyStart;</b>
<b class="fc">&nbsp;    MaxMoney = params.MaxMoney;</b>
<b class="fc">&nbsp;    Reputation = params.Reputation;</b>
<b class="fc">&nbsp;    MaxReputation = 5; // set the max reputation to 5</b>
<b class="fc">&nbsp;    CustomerFrustrationStart = params.FrustrationStart;</b>
&nbsp;
<b class="fc">&nbsp;    groupSize.y = Math.min(params.MaxCustomersPerWave, groupSize.y);</b>
<b class="fc">&nbsp;    groupSize.x = Math.max(params.MinCustomersPerWave, groupSize.x);</b>
&nbsp;
<b class="fc">&nbsp;    CalculateWavesFromNoCustomers(params.NoCustomers);</b>
&nbsp;
<b class="fc">&nbsp;    BlackTexture Black = new BlackTexture(&quot;Black.png&quot;);</b>
<b class="fc">&nbsp;    BlackTexture FrustBack = new BlackTexture(&quot;FrustrationBackground.png&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    FrustrationTimerBackground = new GameObject(FrustBack);</b>
<b class="fc">&nbsp;    FrustrationTimerBackground.position.set(298, 8);</b>
<b class="fc">&nbsp;    FrustBack.layer = -1;</b>
<b class="fc">&nbsp;    FrustBack.setSize(TimerWidth + 4, TimerHeight + 4);</b>
&nbsp;
<b class="fc">&nbsp;    FrustrationTimer = new GameObject(Black);</b>
&nbsp;
<b class="fc">&nbsp;    FrustrationTimer.position.set(300, 10);</b>
&nbsp;
<b class="fc">&nbsp;    if (Waves != -1) {</b>
<b class="fc">&nbsp;      Reputation = Math.min(Reputation, Waves);</b>
&nbsp;    }
<b class="fc">&nbsp;    generateCustomerArray();</b>
&nbsp;
<b class="fc">&nbsp;    int ID = 0;</b>
<b class="fc">&nbsp;    for (Vector2 pos : TablePositions</b>
&nbsp;    ) {
<b class="fc">&nbsp;      tables.add(new Table(pos, ID++, 30));</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    pathfinding = path;</b>
<b class="fc">&nbsp;    OrderAreaTarget = OrderArea;</b>
<b class="fc">&nbsp;    DoorTarget = DoorPosition;</b>
&nbsp;
<b class="fc">&nbsp;    menu = new OrderMenu(10, 7, 3, params.OrderTypePermissable);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Convenience function which helps to calculate the number of customers in each wave of the
&nbsp;   * scenario mode.
&nbsp;   *
&nbsp;   * @param numCustomersPerWave The arraylist which will store the number of customers per wave
&nbsp;   * @param loopValue           Integer used to limit the number of times the while loop executes
&nbsp;   * @return
&nbsp;   */
&nbsp;  private ArrayList&lt;Integer&gt; calculateNumCustomersPerScenarioWave(
&nbsp;      ArrayList&lt;Integer&gt; numCustomersPerWave, int loopValue) {
<b class="fc">&nbsp;    while (loopValue &gt; 0) {</b>
<b class="fc">&nbsp;      if (loopValue &lt; 6) {</b>
<b class="fc">&nbsp;        if (loopValue &lt;= 3) {</b>
<b class="fc">&nbsp;          for (int i = 0; i &lt; loopValue; i++) {</b>
<b class="fc">&nbsp;            customersPerWave.add(1);</b>
&nbsp;          }
<b class="fc">&nbsp;          loopValue = 0;</b>
&nbsp;        } else {
<b class="fc">&nbsp;          loopValue -= 2;</b>
<b class="fc">&nbsp;          customersPerWave.add(2);</b>
&nbsp;        }
&nbsp;      } else {
<b class="fc">&nbsp;        loopValue -= 5;</b>
<b class="fc">&nbsp;        customersPerWave.add(3);</b>
<b class="fc">&nbsp;        customersPerWave.add(2);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return numCustomersPerWave;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public void CalculateWavesFromNoCustomers(int NoCustomers) {
<b class="fc">&nbsp;    MaxCustomers = NoCustomers;</b>
<b class="fc">&nbsp;    CustomersRemaining = NoCustomers;</b>
&nbsp;
<b class="fc">&nbsp;    if (NoCustomers == -1) {</b>
<b class="nc">&nbsp;      SetWaveAmount(-1);</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    customersPerWave = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    int tempVal = MaxCustomers;</b>
&nbsp;
&nbsp;    /* The following block of code calculates the number of customers that should be
&nbsp;     * in each wave of the scenario mode.
&nbsp;     * The number of customers per wave is stored in the customersPerWave arraylist.
&nbsp;     * Waves can have 1, 2, or 3 customers. Waves with fewer customers are more likely to occur.
&nbsp;     */
<b class="fc">&nbsp;    if (tempVal &gt; 10) {</b>
<b class="fc">&nbsp;      double numLoops = Math.floor(tempVal / 10);</b>
<b class="fc">&nbsp;      int finalLoopVal = tempVal % 10; // The remainder of tempVal / 10</b>
<b class="fc">&nbsp;      tempVal = 10; // The waves are calculated with a limit of 10 each time the algorithm</b>
&nbsp;      // is called. This way, it is ensured that waves with fewer customers are more likely to
&nbsp;      // occur.
<b class="fc">&nbsp;      for (int c = 0; c &lt; numLoops; c++) {</b>
<b class="fc">&nbsp;        calculateNumCustomersPerScenarioWave(customersPerWave, tempVal);</b>
&nbsp;      }
&nbsp;      // The following line ensures that the correct number of customers will appear
<b class="fc">&nbsp;      calculateNumCustomersPerScenarioWave(customersPerWave, finalLoopVal);</b>
<b class="fc">&nbsp;    } else {</b>
<b class="fc">&nbsp;      calculateNumCustomersPerScenarioWave(customersPerWave, tempVal);</b>
&nbsp;    }
&nbsp;    // Sorts the arraylist in ascending order so that waves with fewer customers occur first
<b class="fc">&nbsp;    Collections.sort(customersPerWave);</b>
&nbsp;
<b class="fc">&nbsp;    Waves = customersPerWave.size();</b>
<b class="fc">&nbsp;    SetWaveAmount(Waves);</b>
&nbsp;  }
&nbsp;
&nbsp;  public int SittingCustomerCount() {
<b class="fc">&nbsp;    return SittingCustomers.size();</b>
&nbsp;  }
&nbsp;
&nbsp;  public OrderMenu getMenu() {
<b class="fc">&nbsp;    return menu;</b>
&nbsp;  }
&nbsp;
&nbsp;  public ArrayList&lt;Integer&gt; getCustomersPerScenarioWave() {
<b class="fc">&nbsp;    return customersPerWave;</b>
&nbsp;  }
&nbsp;
&nbsp;  /***
&nbsp;   * Set the maximum number of waves to do, exclusively. Resets currentWave to 0.
&nbsp;   * @param amount
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void SetWaveAmount(int amount) {
<b class="fc">&nbsp;    Waves = amount;</b>
<b class="fc">&nbsp;    currentWave = 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Generates a customer array which can be used to get random customer sprites from the customer
&nbsp;   * class
&nbsp;   */
&nbsp;  public void generateCustomerArray() {
&nbsp;    String filename;
&nbsp;    TextureAtlas customerAtlas;
&nbsp;
&nbsp;    //The file path takes it to data for each animation
&nbsp;    //The TextureAtlas creates a texture atlas where the you pass through the string of the number and it returns the image.
&nbsp;    //Taking all pictures in the diretory of the file
<b class="fc">&nbsp;    for (int i = 1; i &lt; 9; i++) {</b>
<b class="fc">&nbsp;      filename = &quot;Customers/Customer&quot; + i + &quot;/customer&quot; + i + &quot;.txt&quot;;</b>
<b class="fc">&nbsp;      customerAtlas = new TextureAtlas(filename);</b>
<b class="fc">&nbsp;      CustomerAtlas.add(customerAtlas);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Updates all customers in groups to update their animation.
&nbsp;   *
&nbsp;   * @param customers
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void UpdateCustomerMovements(List&lt;CustomerGroups&gt; customers) {
<b class="nc">&nbsp;    for (int i = 0; i &lt; customers.size(); i++) {</b>
<b class="nc">&nbsp;      customers.get(i).updateSpriteFromInput();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public CustomerGroups getCurrentWaitingCustomerGroup() {
<b class="fc">&nbsp;    return currentWaiting;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   *  Modifies the reputation, if reputation + DR &lt;= 0 END GAME.
&nbsp;   * @param DR delta reputation
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void ModifyReputation(int DR) {
<b class="fc">&nbsp;    Reputation += DR;</b>
<b class="fc">&nbsp;    Reputation = Math.min(Reputation, MaxReputation);</b>
<b class="fc">&nbsp;    if (Reputation &lt;= 0) {</b>
<b class="fc">&nbsp;      EndGame();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Do check and modify money.
&nbsp;   *
&nbsp;   * @param DM Delta Money
&nbsp;   * @return decrease in money is allowed.
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean ChangeMoney(float DM) {
<b class="fc">&nbsp;    if (DM &gt;= 0) {</b>
<b class="fc">&nbsp;      Money += DM;</b>
<b class="fc">&nbsp;      Money = Math.min(MaxMoney, Money);</b>
<b class="fc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (Money - DM &gt;= 0) {</b>
<b class="nc">&nbsp;      Money += DM;</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return false;</b>
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public void Update(float dt) {
<b class="nc">&nbsp;    super.Update(dt);</b>
<b class="nc">&nbsp;    if (currentWaiting != null) {</b>
<b class="nc">&nbsp;      currentWaiting.showIcons();</b>
<b class="nc">&nbsp;      currentWaiting.removeIcons();</b>
<b class="nc">&nbsp;      currentWaiting.checkClicks();</b>
<b class="nc">&nbsp;      currentWaiting.updateSpriteFromInput();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    UpdateCustomerMovements(SittingCustomers);</b>
<b class="nc">&nbsp;    UpdateCustomerMovements(WalkingBackCustomers);</b>
&nbsp;
<b class="nc">&nbsp;    FrustrationCheck(dt);</b>
&nbsp;
<b class="nc">&nbsp;    RemoveCustomerTest();</b>
<b class="nc">&nbsp;    SeeIfCustomersShouldLeave(dt);</b>
<b class="nc">&nbsp;    CanAcceptNewCustomer();</b>
&nbsp;
<b class="nc">&nbsp;    ChangeFrustrationTimer();</b>
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets the next avalible Table.
&nbsp;   *
&nbsp;   * @return next table. NULL if no free
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public Table GetTable() {
<b class="fc">&nbsp;    for (Table option : tables) {</b>
<b class="fc">&nbsp;      if (option.isFree()) {</b>
<b class="fc">&nbsp;        return option;</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public void ChangeFrustrationTimer() {
&nbsp;
<b class="nc">&nbsp;    float TT  = 0;</b>
<b class="nc">&nbsp;    float Max = CustomerFrustrationStart;</b>
&nbsp;
<b class="nc">&nbsp;    if (currentWaiting != null) {</b>
<b class="nc">&nbsp;      TT = currentWaiting.Frustration;</b>
<b class="nc">&nbsp;      Max *= currentWaiting.Members.size();</b>
&nbsp;    }
<b class="nc">&nbsp;    ((BlackTexture) FrustrationTimer.image).setSize(</b>
&nbsp;        (int) (( TT / Max) * TimerWidth), TimerHeight);
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;  /**
&nbsp;   * Change frustration of the currently waiting customer group
&nbsp;   *
&nbsp;   * @param dt delta time
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  private void FrustrationCheck(float dt) {
<b class="nc">&nbsp;    if (currentWaiting == null) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    currentWaiting.CheckFrustration(dt, FrustrationCallBack);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * See if a currently seated customer should leave to make space for a new customer to enter.
&nbsp;   *
&nbsp;   * @param dt
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void SeeIfCustomersShouldLeave(float dt) {
<b class="fc">&nbsp;    if (SittingCustomers.size() &gt; 0) {</b>
<b class="fc">&nbsp;      NextToLeave -= dt;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (NextToLeave &lt;= 0) {</b>
<b class="fc">&nbsp;      RemoveCurrentlySeatedCustomers();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    TryDeleteCustomers();</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Removes the first currently seated customer and makes them walk outside and despawn.
&nbsp;   */
&nbsp;  void RemoveCurrentlySeatedCustomers() {
<b class="fc">&nbsp;    CustomerGroups groups = SittingCustomers.get(0);</b>
<b class="fc">&nbsp;    groups.table.relinquish();</b>
<b class="fc">&nbsp;    WalkingBackCustomers.add(groups);</b>
<b class="fc">&nbsp;    SittingCustomers.remove(0);</b>
&nbsp;
<b class="fc">&nbsp;    SetCustomerGroupTarget(groups, DoorTarget);</b>
&nbsp;
<b class="fc">&nbsp;    NextToLeave = EatingTime;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Trys to remove customers when they reach the exit.
&nbsp;   */
&nbsp;  void TryDeleteCustomers() {
<b class="fc">&nbsp;    List&lt;Integer&gt; removals = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    int r = 0;</b>
<b class="fc">&nbsp;    for (CustomerGroups group : WalkingBackCustomers</b>
&nbsp;    ) {
&nbsp;
<b class="fc">&nbsp;      for (int i = group.Members.size() - 1; i &gt;= 0; i--) {</b>
&nbsp;
<b class="fc">&nbsp;        if (group.Members.get(i).gameObject.position.dst(DoorTarget.x, DoorTarget.y) &lt; 1) {</b>
<b class="fc">&nbsp;          group.Members.get(i).Destroy();</b>
<b class="fc">&nbsp;          group.Members.remove(i);</b>
&nbsp;        }
&nbsp;
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if (group.Members.size() == 0) {</b>
<b class="fc">&nbsp;        removals.add(r);</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      r++;</b>
&nbsp;
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    for (Integer i : removals) {</b>
<b class="fc">&nbsp;      WalkingBackCustomers.remove(i);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  int WavesLeft() {
<b class="fc">&nbsp;    return Waves - currentWave;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a new customer group of a random size, and gives them a list of foods to order.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;
&nbsp;
&nbsp;  public int calculateCustomerAmount() {
&nbsp;
<b class="fc">&nbsp;    if (Waves == -1) {</b>
<b class="fc">&nbsp;      return rand.nextInt((int) groupSize.y - (int) groupSize.x) + (int) groupSize.x;</b>
&nbsp;    }
<b class="fc">&nbsp;    if (WavesLeft() == 0) {</b>
<b class="fc">&nbsp;      return CustomersRemaining;</b>
&nbsp;    }
&nbsp;
&nbsp;//    int rnd = rand.nextInt((int) groupSize.y - (int) groupSize.x) + (int) groupSize.x;
&nbsp;//
&nbsp;//    int minimumCustomerDraw = WavesLeft() * (int) groupSize.x;
&nbsp;//    int MaxDraw = (CustomersRemaining - rnd) - WavesLeft() * (int) groupSize.y;
&nbsp;//
&nbsp;//    minimumCustomerDraw = CustomersRemaining - minimumCustomerDraw;
&nbsp;//
&nbsp;//    return Math.min(minimumCustomerDraw, rnd) + Math.max(0, MaxDraw);
&nbsp;
&nbsp;    // gets the number of customer for the current wave from the list of customers per wave
<b class="fc">&nbsp;    return customersPerWave.get(currentWave - 1);</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  void CreateNewCustomer() {
<b class="fc">&nbsp;    Table table = GetTable();</b>
&nbsp;
<b class="fc">&nbsp;    int customerAmount = calculateCustomerAmount();</b>
<b class="fc">&nbsp;    CustomersRemaining -= customerAmount;</b>
&nbsp;
<b class="fc">&nbsp;    currentWaiting = new CustomerGroups(customerAmount, currentCustomer, DoorTarget,</b>
<b class="fc">&nbsp;        CustomerFrustrationStart, menu.CreateNewOrder(customerAmount, Randomisation.Normalised),</b>
&nbsp;        CustomerAtlas);
<b class="fc">&nbsp;    currentCustomer += customerAmount;</b>
&nbsp;
<b class="fc">&nbsp;    currentWaiting.table = table;</b>
<b class="fc">&nbsp;    table.DesignateSeating(customerAmount, rand);</b>
&nbsp;
<b class="fc">&nbsp;    SetWaitingForOrderTarget();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Makes the currently waiting customers to queue up dynamically.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  void SetWaitingForOrderTarget() {
<b class="fc">&nbsp;    for (int i = 0; i &lt; currentWaiting.MembersInLine.size(); i++) {</b>
<b class="fc">&nbsp;      SetCustomerTarget(currentWaiting.MembersInLine.get(i),</b>
<b class="fc">&nbsp;          new Vector2(0, 40 * i).add(OrderAreaTarget));</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks if a new customer can be accepted if so, add a new one in. End the game if the set number of waves has elapsed.
&nbsp;   * Set Waves to -1 for &quot;endless&quot;
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;
&nbsp;  public void CanAcceptNewCustomer() {
<b class="fc">&nbsp;    if (DoSatisfactionCheck()) {</b>
<b class="fc">&nbsp;      SittingCustomers.add(currentWaiting);</b>
<b class="fc">&nbsp;      currentWaiting = null;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (currentWaiting == null &amp;&amp; SittingCustomers.size() &lt; tables.size()) {</b>
<b class="fc">&nbsp;      if (Waves != currentWave++) //if not the max number of waves increment</b>
&nbsp;      {
<b class="fc">&nbsp;        CreateNewCustomer();</b>
&nbsp;      } else {
<b class="fc">&nbsp;        EndGame();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * If the current customer is too frustrated then make all customers in that group leave decrement
&nbsp;   * Frustration
&nbsp;   *
&nbsp;   * @param group group to leave
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void FrustrationLeave(CustomerGroups group) {
<b class="nc">&nbsp;    SetCustomerGroupTarget(group, DoorTarget);</b>
<b class="nc">&nbsp;    group.table.relinquish();</b>
<b class="nc">&nbsp;    currentWaiting = null;</b>
<b class="nc">&nbsp;    WalkingBackCustomers.add(group);</b>
<b class="nc">&nbsp;    ModifyReputation(-1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets the pathfinding target of an entire group, making them walk to the location.
&nbsp;   *
&nbsp;   * @param group
&nbsp;   * @param target
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void SetCustomerGroupTarget(CustomerGroups group, Vector2 target) {
<b class="fc">&nbsp;    for (Customer customer : group.Members</b>
&nbsp;    ) {
<b class="fc">&nbsp;      SetCustomerTarget(customer, target);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets an individual customers pathfinding target. Begins pathfinding
&nbsp;   *
&nbsp;   * @param customer
&nbsp;   * @param target
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;
&nbsp;  public void SetCustomerTarget(Customer customer, Vector2 target) {
<b class="fc">&nbsp;    customer.GivePath(pathfinding.FindPath((int) customer.gameObject.position.x,</b>
&nbsp;        (int) customer.gameObject.position.y, (int) target.x, (int) target.y,
&nbsp;        DistanceTest.Manhatten));
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Test remove customers.
&nbsp;   */
&nbsp;  void RemoveCustomerTest() {
<b class="nc">&nbsp;    if (Gdx.input.isKeyJustPressed(</b>
&nbsp;        Keys.S) &amp;&amp; currentWaiting != null) {
<b class="nc">&nbsp;      Customer customer = currentWaiting.RemoveFirstCustomer();</b>
<b class="nc">&nbsp;      SetCustomerTarget(customer, currentWaiting.table.GetNextSeat());</b>
<b class="nc">&nbsp;      ChangeMoney(MoneyPerCustomer);</b>
<b class="nc">&nbsp;      SetWaitingForOrderTarget();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void superFoodUpgrade() {
<b class="nc">&nbsp;    RemoveCustomerTest();</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * End the game sequence. Call upper end game sequence.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  private void EndGame() {
&nbsp;    //calculate win or loss
&nbsp;
&nbsp;    //Calculate points
<b class="fc">&nbsp;    EndOfGameValues values = new EndOfGameValues();</b>
<b class="fc">&nbsp;    values.score = Money;</b>
<b class="fc">&nbsp;    values.Won = Reputation &gt; 0;</b>
<b class="fc">&nbsp;    CallEndGame.accept(values);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Interface with the customer from the chefs via customer counters. Checks to see if the given
&nbsp;   * food is an ordered food Makes customer sit down if so
&nbsp;   *
&nbsp;   * @param item
&nbsp;   * @return True if accepted, otherwise false
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean tryGiveFood(Item item) {
<b class="fc">&nbsp;    int success = currentWaiting.SeeIfDishIsCorrect(item);</b>
&nbsp;
<b class="fc">&nbsp;    if (success != -1) {</b>
<b class="fc">&nbsp;      currentWaiting.MembersSeatedOrWalking.add(currentWaiting.MembersInLine.remove(success));</b>
<b class="fc">&nbsp;      currentWaiting.updateFrustrationOnSucessfulService();</b>
<b class="fc">&nbsp;      SetCustomerTarget(currentWaiting.MembersSeatedOrWalking.get(</b>
<b class="fc">&nbsp;          currentWaiting.MembersSeatedOrWalking.size() - 1), currentWaiting.table.GetNextSeat());</b>
<b class="fc">&nbsp;      SetWaitingForOrderTarget();</b>
<b class="fc">&nbsp;      ChangeMoney(MoneyPerCustomer);</b>
&nbsp;    }
<b class="fc">&nbsp;    return success != -1;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks to see if the current customer group can be expelled from the currenly waiting slot
&nbsp;   *
&nbsp;   * @return True if so, otherwise false
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean DoSatisfactionCheck() {
<b class="fc">&nbsp;    return currentWaiting != null &amp;&amp; currentWaiting.MembersInLine.size() == 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  public void deleteAllCustomers() {
<b class="nc">&nbsp;    if (currentWaiting != null) {</b>
<b class="nc">&nbsp;      currentWaiting.destroy();</b>
&nbsp;
&nbsp;    }
<b class="nc">&nbsp;    for (CustomerGroups group : SittingCustomers) {</b>
<b class="nc">&nbsp;      group.destroy();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    for (CustomerGroups group : WalkingBackCustomers) {</b>
<b class="nc">&nbsp;      group.destroy();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    SittingCustomers.clear();</b>
<b class="nc">&nbsp;    WalkingBackCustomers.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Loads the state of the game from a GameState object.
&nbsp;   *
&nbsp;   * @param state The state to load
&nbsp;   * @author Felix Seanor
&nbsp;   * @author Jack Vickers
&nbsp;   */
&nbsp;  public void LoadState(GameState state) {
&nbsp;    //Wave State
<b class="nc">&nbsp;    currentWave = state.Wave;</b>
<b class="nc">&nbsp;    Waves = state.MaxWave;</b>
<b class="nc">&nbsp;    groupSize = state.GroupSize;</b>
&nbsp;    //Reputation
<b class="nc">&nbsp;    Reputation = state.Reputation;</b>
<b class="nc">&nbsp;    MaxReputation = state.MaxReputation;</b>
<b class="nc">&nbsp;    CustomerFrustrationStart = state.MaxFrustration;</b>
&nbsp;    //Money
<b class="nc">&nbsp;    MaxMoney = state.MaxMoney;</b>
<b class="nc">&nbsp;    Money = state.Money;</b>
&nbsp;
<b class="nc">&nbsp;    customersPerWave = state.CustomersPerWave;</b>
<b class="nc">&nbsp;    if (!Objects.isNull(customersPerWave)) { // if this is not null, a scenario game is being loaded</b>
<b class="nc">&nbsp;      if (customersPerWave.size() &gt; 0) { // this is true for the scenario mode</b>
<b class="nc">&nbsp;        CustomersRemaining = 0;</b>
&nbsp;      }
&nbsp;      // correctly calculates the number of customers remaining (scenario mode)
<b class="nc">&nbsp;      for (int i = currentWave; i &lt; customersPerWave.size(); i++) {</b>
<b class="nc">&nbsp;        CustomersRemaining += customersPerWave.get(i);</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    deleteAllCustomers();</b>
&nbsp;
<b class="nc">&nbsp;    if (state.CustomerGroupsData[0] != null) {</b>
<b class="nc">&nbsp;      currentWaiting = new CustomerGroups(state.CustomerGroupsData[0], CustomerAtlas);</b>
<b class="nc">&nbsp;      Table table = tables.get(state.CustomerGroupsData[0].Table);</b>
<b class="nc">&nbsp;      table.DesignateSeating(state.CustomerGroupsData[0].customerPositions.length, rand);</b>
<b class="nc">&nbsp;      currentWaiting.table = table;</b>
&nbsp;
&nbsp;      // if there are customers walking to the table
<b class="nc">&nbsp;      if (state.CustomerGroupsData[0].NumCustomersWalkingToTable &gt; 0) {</b>
<b class="nc">&nbsp;        for (Customer cust : currentWaiting.Members) {</b>
&nbsp;          // If the customer is not at the order point and is not at the entrance (therefore is moving towards a table)
<b class="nc">&nbsp;          if ((cust.getX() &gt; 360.0f || cust.getX() &lt; 360.0f) &amp;&amp; (cust.getX() != 200</b>
<b class="nc">&nbsp;              &amp;&amp; cust.getY() != 100)) {</b>
<b class="nc">&nbsp;            SetCustomerTarget(cust,</b>
<b class="nc">&nbsp;                currentWaiting.table.GetNextSeat()); // set the customer to walk to the table</b>
<b class="nc">&nbsp;            currentWaiting.MembersInLine.remove(cust); // remove the customer from the line</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;
&nbsp;      // set the target of the customers who should be in line to the order point
<b class="nc">&nbsp;      SetWaitingForOrderTarget();</b>
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    int i = 0;</b>
<b class="nc">&nbsp;    for (CustomerGroupState groupState : state.CustomerGroupsData</b>
&nbsp;    ) {
<b class="nc">&nbsp;      if (i == 0) {</b>
<b class="nc">&nbsp;        i++;</b>
<b class="nc">&nbsp;        continue;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      CustomerGroups customerGroups = new CustomerGroups(groupState, CustomerAtlas);</b>
<b class="nc">&nbsp;      Table table = tables.get(state.CustomerGroupsData[i].Table);</b>
<b class="nc">&nbsp;      if (groupState.leaving) { // customers are leaving</b>
<b class="nc">&nbsp;        SetCustomerGroupTarget(customerGroups, DoorTarget);</b>
<b class="nc">&nbsp;        WalkingBackCustomers.add(customerGroups);</b>
&nbsp;      } else { // customers are/ should be sitting
<b class="nc">&nbsp;        customerGroups.table = table;</b>
<b class="nc">&nbsp;        table.DesignateSeating(state.CustomerGroupsData[i].customerPositions.length, rand);</b>
&nbsp;
&nbsp;        // ensures that a table target is set for these customers
<b class="nc">&nbsp;        for (Customer cust : customerGroups.Members) {</b>
<b class="nc">&nbsp;          SetCustomerTarget(cust, table.GetNextSeat());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        SittingCustomers.add(customerGroups);</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      i++;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  public void SaveState(GameState state) {
<b class="fc">&nbsp;    state.Wave = currentWave;</b>
&nbsp;
&nbsp;    // List of number of customers per wave
<b class="fc">&nbsp;    state.CustomersPerWave = customersPerWave;</b>
&nbsp;
<b class="fc">&nbsp;    state.MaxWave = Waves;</b>
<b class="fc">&nbsp;    state.GroupSize = groupSize;</b>
&nbsp;    //Reputation
<b class="fc">&nbsp;    state.Reputation = Reputation;</b>
<b class="fc">&nbsp;    state.MaxReputation = MaxReputation;</b>
<b class="fc">&nbsp;    state.MaxFrustration = CustomerFrustrationStart;</b>
&nbsp;    //Money
<b class="fc">&nbsp;    state.MaxMoney = MaxMoney;</b>
<b class="fc">&nbsp;    state.Money = Money;</b>
&nbsp;
&nbsp;    //Customers
&nbsp;
<b class="fc">&nbsp;    List&lt;CustomerGroupState&gt; savedGroups = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    if (currentWaiting == null) {</b>
<b class="fc">&nbsp;      savedGroups.add(null);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      savedGroups.add(currentWaiting.SaveState(false)); // customer groups that are waiting</b>
&nbsp;
&nbsp;    }
<b class="fc">&nbsp;    for (CustomerGroups group : SittingCustomers) { // customer groups that are sitting</b>
<b class="nc">&nbsp;      savedGroups.add(group.SaveState(false));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    for (CustomerGroups group : WalkingBackCustomers) { // customer groups that are leaving</b>
<b class="nc">&nbsp;      if (group.Members.size() &gt; 0) {</b>
<b class="nc">&nbsp;        savedGroups.add(group.SaveState(true));</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="fc">&nbsp;    state.CustomerGroupsData = savedGroups.toArray(new CustomerGroupState[0]);</b>
&nbsp;  }
&nbsp;
&nbsp;  public int LeavingCustomerCount() {
<b class="fc">&nbsp;    return WalkingBackCustomers.size();</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-04-24 20:42</div>
</div>
</body>
</html>
