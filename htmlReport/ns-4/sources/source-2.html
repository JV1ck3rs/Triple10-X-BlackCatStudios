


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CustomerController</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.mygdx.game.Core.Customers</a>
</div>

<h1>Coverage Summary for Class: CustomerController (com.mygdx.game.Core.Customers)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CustomerController</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.7%
  </span>
  <span class="absValue">
    (37/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.9%
  </span>
  <span class="absValue">
    (264/339)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.mygdx.game.Core.Customers;
&nbsp;
&nbsp;import com.badlogic.gdx.Gdx;
&nbsp;import com.badlogic.gdx.Input.Keys;
&nbsp;import com.badlogic.gdx.graphics.g2d.TextureAtlas;
&nbsp;import com.badlogic.gdx.math.Vector2;
&nbsp;import com.mygdx.game.Core.GameState.CustomerGroupState;
&nbsp;import com.mygdx.game.Core.GameState.GameState;
&nbsp;import com.mygdx.game.Core.Inputs;
&nbsp;import com.mygdx.game.Core.PathFinder.DistanceTest;
&nbsp;import com.mygdx.game.Core.PathFinder.Pathfinding;
&nbsp;import com.mygdx.game.Core.Rendering.BlackTexture;
&nbsp;import com.mygdx.game.Core.Rendering.GameObject;
&nbsp;import com.mygdx.game.Core.SFX.SoundFrame;
&nbsp;import com.mygdx.game.Core.SFX.SoundFrame.soundsEnum;
&nbsp;import com.mygdx.game.Core.Scriptable;
&nbsp;import com.mygdx.game.Core.ValueStructures.CustomerControllerParams;
&nbsp;import com.mygdx.game.Core.ValueStructures.EndOfGameValues;
&nbsp;import com.mygdx.game.Items.Item;
&nbsp;import com.mygdx.game.Items.ItemEnum;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Random;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;/**
&nbsp; * This script controls the customers and handles their logic through a variety of secondary
&nbsp; * scripts. Also handles when the current game should end.
&nbsp; * &lt;p&gt;
&nbsp; * BlackCatStudio&#39;s Code
&nbsp; *
&nbsp; * @author Felix Seanor
&nbsp; * @author Jack Vickers &lt;p&gt; Last modified: 23/04/2023
&nbsp; */
&nbsp;public class CustomerController extends Scriptable {
&nbsp;
&nbsp;  /**
&nbsp;   * The current customer group waiting in line
&nbsp;   */
<b class="fc">&nbsp;  CustomerGroups currentWaitingCustomer = null;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * List of customers sitting down and eating. Groups only enter this when all members are eating
&nbsp;   */
<b class="fc">&nbsp;  List&lt;CustomerGroups&gt; sittingCustomers = new LinkedList&lt;&gt;();</b>
&nbsp;  /**
&nbsp;   * List of all customer groups trying to leave
&nbsp;   */
<b class="fc">&nbsp;  List&lt;CustomerGroups&gt; walkingBackCustomers = new LinkedList&lt;&gt;();</b>
&nbsp;  /**
&nbsp;   * Pathfinding module used
&nbsp;   */
&nbsp;  Pathfinding pathfinding;
&nbsp;
&nbsp;  /**
&nbsp;   * List of tables
&nbsp;   */
&nbsp;  List&lt;Table&gt; tables;
&nbsp;  /**
&nbsp;   * Call this to start endge game sequence
&nbsp;   */
&nbsp;  Consumer&lt;EndOfGameValues&gt; callEndGame;
&nbsp;
&nbsp;  /**
&nbsp;   * The Reputation.
&nbsp;   */
&nbsp;  public int reputation;
&nbsp;  /**
&nbsp;   * The constant money.
&nbsp;   */
&nbsp;  public static int money;
&nbsp;  /**
&nbsp;   * The Max money.
&nbsp;   */
&nbsp;  int maxMoney;
&nbsp;  /**
&nbsp;   * The Max reputation.
&nbsp;   */
&nbsp;  int maxReputation;
&nbsp;  /**
&nbsp;   * The Money per customer.
&nbsp;   */
&nbsp;  int moneyPerCustomer;
&nbsp;
&nbsp;  /**
&nbsp;   * The Waves.
&nbsp;   */
<b class="fc">&nbsp;  int waves = -1;</b>
&nbsp;  /**
&nbsp;   * The Menu.
&nbsp;   */
&nbsp;  public OrderMenu menu;
&nbsp;  /**
&nbsp;   * The Current customer.
&nbsp;   */
<b class="fc">&nbsp;  int currentCustomer = 0;</b>
&nbsp;  /**
&nbsp;   * The Current wave.
&nbsp;   */
<b class="fc">&nbsp;  int currentWave = 0;</b>
<b class="fc">&nbsp;  private float eatingTime = 7;</b>
<b class="fc">&nbsp;  private int timerWidth = 50;</b>
<b class="fc">&nbsp;  private int timerHeight = 10;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * The Ovens added.
&nbsp;   */
<b class="fc">&nbsp;  Boolean OvensAdded = false;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Frustration Time
&nbsp;   */
&nbsp;  private GameObject frustrationTimer;
&nbsp;  private GameObject frustrationTimerBackground;
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a new randomisation class based on the current time
&nbsp;   */
<b class="fc">&nbsp;  Random rand = new Random(System.currentTimeMillis());</b>
&nbsp;
&nbsp;  /**
&nbsp;   * The minimum and maximum group size for customers groups
&nbsp;   */
<b class="fc">&nbsp;  private Vector2 groupSize = new Vector2(1, 4);</b>
&nbsp;
&nbsp;  /**
&nbsp;   * timer defining when the next eating customer will leave
&nbsp;   */
<b class="fc">&nbsp;  float timeToNextCustomerLeaving = eatingTime;</b>
&nbsp;  /**
&nbsp;   * The Max customers.
&nbsp;   */
&nbsp;  int maxCustomers;
&nbsp;  /**
&nbsp;   * The Customers remaining.
&nbsp;   */
&nbsp;  int customersRemaining;
&nbsp;  /**
&nbsp;   * The Customers per wave.
&nbsp;   */
&nbsp;  ArrayList&lt;Integer&gt; customersPerWave;
&nbsp;  /**
&nbsp;   * this is call back for customer groups who get too frustrated so they need to leave
&nbsp;   */
&nbsp;  Consumer&lt;CustomerGroups&gt; frustrationCallBack;
&nbsp;
&nbsp;  /**
&nbsp;   * Door position
&nbsp;   */
&nbsp;  Vector2 doorTarget;
&nbsp;  /**
&nbsp;   * where ordering queue should start
&nbsp;   */
&nbsp;  Vector2 orderAreaTarget;
&nbsp;
&nbsp;  /**
&nbsp;   * All customer texture atlases
&nbsp;   */
<b class="fc">&nbsp;  public ArrayList&lt;TextureAtlas&gt; customerAtlas = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * how long it takes for a group to be frustrated and leave without being served
&nbsp;   */
&nbsp;  private int customerFrustrationStart;
&nbsp;
&nbsp;  /**
&nbsp;   * The Update frustration.
&nbsp;   */
<b class="fc">&nbsp;  public boolean updateFrustration = true;</b>
&nbsp;  /**
&nbsp;   * The Num customers served.
&nbsp;   */
<b class="fc">&nbsp;  int numCustomersServed = 0;</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Creates the customer controller
&nbsp;   *
&nbsp;   * @param DoorPosition     Customer spawn and exit.
&nbsp;   * @param OrderArea        First position in order line
&nbsp;   * @param path             Pathfinding Module.
&nbsp;   * @param CallUpGameFinish Game Finish Function.
&nbsp;   * @param params           Parameter class
&nbsp;   * @param tables           Where the tables are, TEMPORARY
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public CustomerController(Vector2 DoorPosition, Vector2 OrderArea, Pathfinding path,
&nbsp;      Consumer&lt;EndOfGameValues&gt; CallUpGameFinish, CustomerControllerParams params,
<b class="fc">&nbsp;      Vector2... tables) {</b>
<b class="fc">&nbsp;    frustrationCallBack = (CustomerGroups a) -&gt; frustrationLeave(a);</b>
<b class="fc">&nbsp;    moneyPerCustomer = params.moneyPerCustomer;</b>
<b class="fc">&nbsp;    callEndGame = CallUpGameFinish;</b>
<b class="fc">&nbsp;    money = params.moneyStart;</b>
<b class="fc">&nbsp;    maxMoney = params.maxMoney;</b>
<b class="fc">&nbsp;    reputation = params.reputation;</b>
<b class="fc">&nbsp;    maxReputation = 5; // set the max reputation to 5</b>
<b class="fc">&nbsp;    customerFrustrationStart = params.frustrationStart;</b>
<b class="fc">&nbsp;    groupSize.y = Math.min(params.maxCustomersPerWave, groupSize.y);</b>
<b class="fc">&nbsp;    groupSize.x = Math.max(params.minCustomersPerWave, groupSize.x);</b>
&nbsp;
<b class="fc">&nbsp;    calculateWavesFromNoCustomers(params.noCustomers);</b>
&nbsp;
<b class="fc">&nbsp;    BlackTexture Black = new BlackTexture(&quot;Black.png&quot;);</b>
<b class="fc">&nbsp;    BlackTexture FrustBack = new BlackTexture(&quot;FrustrationBackground.png&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    frustrationTimerBackground = new GameObject(FrustBack);</b>
<b class="fc">&nbsp;    frustrationTimerBackground.position.set(298, 8);</b>
<b class="fc">&nbsp;    FrustBack.layer = -1;</b>
<b class="fc">&nbsp;    FrustBack.setSize(timerWidth + 4, timerHeight + 4);</b>
&nbsp;
<b class="fc">&nbsp;    frustrationTimer = new GameObject(Black);</b>
&nbsp;
<b class="fc">&nbsp;    frustrationTimer.position.set(300, 10);</b>
&nbsp;
<b class="fc">&nbsp;    setTables(tables);</b>
&nbsp;
<b class="fc">&nbsp;    if (waves != -1) {</b>
<b class="fc">&nbsp;      reputation = Math.min(reputation, waves);</b>
&nbsp;    }
<b class="fc">&nbsp;    generateCustomerArray();</b>
&nbsp;
<b class="fc">&nbsp;    pathfinding = path;</b>
<b class="fc">&nbsp;    orderAreaTarget = OrderArea;</b>
<b class="fc">&nbsp;    doorTarget = DoorPosition;</b>
&nbsp;
<b class="fc">&nbsp;    menu = new OrderMenu(10, 7, 3, params.orderTypePermissable);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Convenience function which helps to calculate the number of customers in each wave of the
&nbsp;   * scenario mode.
&nbsp;   *
&nbsp;   * @param numCustomersPerWave The arraylist which will store the number of customers per wave
&nbsp;   * @param loopValue           Integer used to limit the number of times the while loop executes
&nbsp;   * @return
&nbsp;   */
&nbsp;  private ArrayList&lt;Integer&gt; calculateNumCustomersPerScenarioWave(
&nbsp;      ArrayList&lt;Integer&gt; numCustomersPerWave, int loopValue) {
<b class="fc">&nbsp;    while (loopValue &gt; 0) {</b>
<b class="fc">&nbsp;      if (loopValue &lt; 6) {</b>
<b class="fc">&nbsp;        if (loopValue &lt;= 3) {</b>
<b class="fc">&nbsp;          for (int i = 0; i &lt; loopValue; i++) {</b>
<b class="fc">&nbsp;            customersPerWave.add(1);</b>
&nbsp;          }
&nbsp;
<b class="fc">&nbsp;          loopValue = 0;</b>
&nbsp;        } else {
<b class="fc">&nbsp;          loopValue -= 2;</b>
<b class="fc">&nbsp;          customersPerWave.add(2);</b>
&nbsp;        }
&nbsp;      } else {
<b class="fc">&nbsp;        loopValue -= 5;</b>
<b class="fc">&nbsp;        customersPerWave.add(3);</b>
<b class="fc">&nbsp;        customersPerWave.add(2);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return numCustomersPerWave;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets money.
&nbsp;   *
&nbsp;   * @return the money
&nbsp;   */
&nbsp;  public int getMoney() {
<b class="nc">&nbsp;    return money;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Sets tables.
&nbsp;   *
&nbsp;   * @param tab the tab
&nbsp;   */
&nbsp;  public void setTables(Vector2... tab) {
<b class="fc">&nbsp;    int ID = 0;</b>
<b class="fc">&nbsp;    tables = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (Vector2 pos : tab</b>
&nbsp;    ) {
<b class="fc">&nbsp;      tables.add(new Table(pos.add(5, 10), ID++, 35));</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Calculate waves from no customers.
&nbsp;   *
&nbsp;   * @param NoCustomers the no customers
&nbsp;   */
&nbsp;  public void calculateWavesFromNoCustomers(int NoCustomers) {
<b class="fc">&nbsp;    maxCustomers = NoCustomers;</b>
<b class="fc">&nbsp;    customersRemaining = NoCustomers;</b>
&nbsp;
<b class="fc">&nbsp;    if (NoCustomers == -1) {</b>
<b class="nc">&nbsp;      setWaveAmount(-1);</b>
&nbsp;      return;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    customersPerWave = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    int tempVal = maxCustomers;</b>
&nbsp;
&nbsp;    /* The following block of code calculates the number of customers that should be
&nbsp;     * in each wave of the scenario mode.
&nbsp;     * The number of customers per wave is stored in the customersPerWave arraylist.
&nbsp;     * Waves can have 1, 2, or 3 customers. Waves with fewer customers are more likely to occur.
&nbsp;     */
<b class="fc">&nbsp;    if (tempVal &gt; 10) {</b>
<b class="fc">&nbsp;      double numLoops = Math.floor(tempVal / 10);</b>
<b class="fc">&nbsp;      int finalLoopVal = tempVal % 10; // The remainder of tempVal / 10</b>
<b class="fc">&nbsp;      tempVal = 10; // The waves are calculated with a limit of 10 each time the algorithm</b>
&nbsp;      // is called. This way, it is ensured that waves with fewer customers are more likely to
&nbsp;      // occur.
<b class="fc">&nbsp;      for (int c = 0; c &lt; numLoops; c++) {</b>
<b class="fc">&nbsp;        calculateNumCustomersPerScenarioWave(customersPerWave, tempVal);</b>
&nbsp;      }
&nbsp;      // The following line ensures that the correct number of customers will appear
<b class="fc">&nbsp;      calculateNumCustomersPerScenarioWave(customersPerWave, finalLoopVal);</b>
<b class="fc">&nbsp;    } else {</b>
<b class="fc">&nbsp;      calculateNumCustomersPerScenarioWave(customersPerWave, tempVal);</b>
&nbsp;    }
&nbsp;    // Sorts the arraylist in ascending order so that waves with fewer customers occur first
<b class="fc">&nbsp;    Collections.sort(customersPerWave);</b>
&nbsp;
<b class="fc">&nbsp;    waves = customersPerWave.size();</b>
<b class="fc">&nbsp;    setWaveAmount(waves);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sitting customer count int.
&nbsp;   *
&nbsp;   * @return the int
&nbsp;   */
&nbsp;  public int sittingCustomerCount() {
<b class="fc">&nbsp;    return sittingCustomers.size();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets menu.
&nbsp;   *
&nbsp;   * @return the menu
&nbsp;   */
&nbsp;  public OrderMenu getMenu() {
<b class="fc">&nbsp;    return menu;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Used to update the ordermenu when an oven has been bought
&nbsp;   *
&nbsp;   * @param a the a
&nbsp;   * @author Jack Hinton
&nbsp;   */
&nbsp;  public void updateMenu(boolean a) {
&nbsp;
<b class="fc">&nbsp;    if (!OvensAdded) {</b>
<b class="fc">&nbsp;      menu.ovenAdded();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    menu.restock();</b>
&nbsp;
<b class="fc">&nbsp;    OvensAdded = a;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets customers per scenario wave.
&nbsp;   *
&nbsp;   * @return the customers per scenario wave
&nbsp;   */
&nbsp;  public ArrayList&lt;Integer&gt; getCustomersPerScenarioWave() {
<b class="fc">&nbsp;    return customersPerWave;</b>
&nbsp;  }
&nbsp;
&nbsp;  /***
&nbsp;   * Set the maximum number of waves to do, exclusively. Resets currentWave to 0.
&nbsp;   * @param amount the amount
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void setWaveAmount(int amount) {
<b class="fc">&nbsp;    waves = amount;</b>
<b class="fc">&nbsp;    currentWave = 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Generates a customer array which can be used to get random customer sprites from the customer
&nbsp;   * class
&nbsp;   */
&nbsp;  public void generateCustomerArray() {
&nbsp;    String filename;
&nbsp;    TextureAtlas customerAtlas;
&nbsp;
&nbsp;    //The file path takes it to data for each animation
&nbsp;    //The TextureAtlas creates a texture atlas where the you pass through the string of the number and it returns the image.
&nbsp;    //Taking all pictures in the diretory of the file
<b class="fc">&nbsp;    for (int i = 1; i &lt; 9; i++) {</b>
<b class="fc">&nbsp;      filename = &quot;Customers/Customer&quot; + i + &quot;/customer&quot; + i + &quot;.txt&quot;;</b>
<b class="fc">&nbsp;      customerAtlas = new TextureAtlas(filename);</b>
<b class="fc">&nbsp;      this.customerAtlas.add(customerAtlas);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Updates all customers in groups to update their animation.
&nbsp;   *
&nbsp;   * @param customers the customers
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void updateCustomerMovements(List&lt;CustomerGroups&gt; customers) {
<b class="nc">&nbsp;    for (int i = 0; i &lt; customers.size(); i++) {</b>
<b class="nc">&nbsp;      customers.get(i).updateSpriteFromInput();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets current waiting customer group.
&nbsp;   *
&nbsp;   * @return the current waiting customer group
&nbsp;   */
&nbsp;  public CustomerGroups getCurrentWaitingCustomerGroup() {
<b class="fc">&nbsp;    return currentWaitingCustomer;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets current waiting customer group.
&nbsp;   *
&nbsp;   * @param group the group
&nbsp;   */
&nbsp;  public void setCurrentWaitingCustomerGroup(CustomerGroups group) {
<b class="fc">&nbsp;    currentWaitingCustomer = group;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets number of customers served.
&nbsp;   *
&nbsp;   * @return the number of customers served
&nbsp;   */
&nbsp;  public int getNumberOfCustomersServed() {
<b class="fc">&nbsp;    return numCustomersServed;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets remaining number of customers.
&nbsp;   *
&nbsp;   * @return the remaining number of customers
&nbsp;   */
&nbsp;  public int getRemainingNumberOfCustomers() {
<b class="nc">&nbsp;    if (currentWaitingCustomer != null) {</b>
<b class="nc">&nbsp;      return customersRemaining + currentWaitingCustomer.membersInLine.size();</b>
&nbsp;    }
<b class="nc">&nbsp;    return customersRemaining;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Modifies the reputation, if reputation + DR &lt;= 0 END GAME.
&nbsp;   *
&nbsp;   * @param DR delta reputation
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void modifyReputation(int DR) {
<b class="fc">&nbsp;    reputation += DR;</b>
<b class="fc">&nbsp;    reputation = Math.min(reputation, maxReputation);</b>
<b class="fc">&nbsp;    if (reputation &lt;= 0) {</b>
<b class="fc">&nbsp;      endGame();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Do check and modify money.
&nbsp;   *
&nbsp;   * @param DM Delta Money
&nbsp;   * @return decrease in money is allowed.
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean changeMoney(float DM) {
<b class="fc">&nbsp;    if (DM &gt;= 0) {</b>
<b class="fc">&nbsp;      money += DM;</b>
<b class="fc">&nbsp;      money = Math.min(maxMoney, money);</b>
<b class="fc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (money - DM &gt;= 0) {</b>
<b class="nc">&nbsp;      money += DM;</b>
<b class="nc">&nbsp;      SoundFrame.SoundEngine.playSound(soundsEnum.BuyItem);</b>
<b class="nc">&nbsp;      return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    return false;</b>
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public void update(float dt) {
<b class="nc">&nbsp;    super.update(dt);</b>
&nbsp;
<b class="nc">&nbsp;    if (Gdx.input.isKeyJustPressed(Inputs.SELL_RESTURANT)) {</b>
<b class="nc">&nbsp;      reputation = 0;</b>
<b class="nc">&nbsp;      endGame();</b>
&nbsp;      ;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    if (currentWaitingCustomer != null) {</b>
<b class="nc">&nbsp;      currentWaitingCustomer.showIcons();</b>
<b class="nc">&nbsp;      currentWaitingCustomer.checkClicks();</b>
<b class="nc">&nbsp;      currentWaitingCustomer.updateSpriteFromInput();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    updateCustomerMovements(sittingCustomers);</b>
<b class="nc">&nbsp;    updateCustomerMovements(walkingBackCustomers);</b>
&nbsp;
<b class="nc">&nbsp;    frustrationCheck(dt);</b>
&nbsp;
<b class="nc">&nbsp;    removeCustomerTest();</b>
<b class="nc">&nbsp;    seeIfCustomersShouldLeave(dt);</b>
<b class="nc">&nbsp;    canAcceptNewCustomer();</b>
&nbsp;
<b class="nc">&nbsp;    changeFrustrationTimer();</b>
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets the next avalible Table.
&nbsp;   *
&nbsp;   * @return next table. NULL if no free
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public Table getTable() {
<b class="fc">&nbsp;    for (Table option : tables) {</b>
<b class="fc">&nbsp;      if (option.isFree()) {</b>
<b class="fc">&nbsp;        return option;</b>
&nbsp;      }
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    return null;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Change frustration timer.
&nbsp;   */
&nbsp;  public void changeFrustrationTimer() {
&nbsp;
<b class="nc">&nbsp;    float TT = 0;</b>
<b class="nc">&nbsp;    float Max = customerFrustrationStart;</b>
&nbsp;
<b class="nc">&nbsp;    if (currentWaitingCustomer != null) {</b>
<b class="nc">&nbsp;      TT = currentWaitingCustomer.frustration;</b>
<b class="nc">&nbsp;      Max *= currentWaitingCustomer.members.size();</b>
&nbsp;    }
<b class="nc">&nbsp;    ((BlackTexture) frustrationTimer.image).setSize(</b>
&nbsp;        (int) ((TT / Max) * timerWidth), timerHeight);
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Change frustration of the currently waiting customer group
&nbsp;   *
&nbsp;   * @param dt delta time
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  private void frustrationCheck(float dt) {
<b class="nc">&nbsp;    if (currentWaitingCustomer == null) {</b>
&nbsp;      return;
&nbsp;    }
<b class="nc">&nbsp;    currentWaitingCustomer.checkFrustration(dt, frustrationCallBack, updateFrustration);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * See if a currently seated customer should leave to make space for a new customer to enter.
&nbsp;   *
&nbsp;   * @param dt the dt
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void seeIfCustomersShouldLeave(float dt) {
<b class="fc">&nbsp;    if (sittingCustomers.size() &gt; 0) {</b>
<b class="fc">&nbsp;      timeToNextCustomerLeaving -= dt;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (timeToNextCustomerLeaving &lt;= 0) {</b>
<b class="fc">&nbsp;      removeCurrentlySeatedCustomers();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    tryDeleteCustomers();</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Removes the first currently seated customer and makes them walk outside and despawn.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  void removeCurrentlySeatedCustomers() {
<b class="fc">&nbsp;    CustomerGroups groups = sittingCustomers.get(0);</b>
<b class="fc">&nbsp;    groups.table.relinquish();</b>
<b class="fc">&nbsp;    walkingBackCustomers.add(groups);</b>
<b class="fc">&nbsp;    sittingCustomers.remove(0);</b>
&nbsp;
<b class="fc">&nbsp;    for (Customer customer : groups.members</b>
&nbsp;    ) {
<b class="fc">&nbsp;      customer.eaten = true;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    setCustomerGroupTarget(groups, doorTarget);</b>
&nbsp;
<b class="fc">&nbsp;    timeToNextCustomerLeaving = eatingTime;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Trys to remove customers when they reach the exit.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  void tryDeleteCustomers() {
<b class="fc">&nbsp;    List&lt;Integer&gt; removals = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    int r = 0;</b>
<b class="fc">&nbsp;    for (CustomerGroups group : walkingBackCustomers</b>
&nbsp;    ) {
&nbsp;
<b class="fc">&nbsp;      for (int i = group.members.size() - 1; i &gt;= 0; i--) {</b>
&nbsp;
<b class="fc">&nbsp;        if (group.members.get(i).gameObject.position.dst(doorTarget.x, doorTarget.y) &lt; 1) {</b>
<b class="fc">&nbsp;          group.members.get(i).destroy();</b>
<b class="fc">&nbsp;          group.members.remove(i);</b>
&nbsp;        }
&nbsp;
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      if (group.members.size() == 0) {</b>
<b class="fc">&nbsp;        removals.add(r);</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      r++;</b>
&nbsp;
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    for (Integer i : removals) {</b>
<b class="fc">&nbsp;      walkingBackCustomers.remove(i);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Waves left int.
&nbsp;   *
&nbsp;   * @return the int
&nbsp;   */
&nbsp;  int wavesLeft() {
<b class="fc">&nbsp;    return waves - currentWave;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Creates a new customer group of a random size, and gives them a list of foods to order.
&nbsp;   *
&nbsp;   * @return the int
&nbsp;   * @author Felix Seanor
&nbsp;   * @author Jack Vickers
&nbsp;   */
&nbsp;
&nbsp;
&nbsp;  public int calculateCustomerAmount() {
&nbsp;
<b class="fc">&nbsp;    if (waves == -1) {</b>
<b class="fc">&nbsp;      return rand.nextInt((int) groupSize.y - (int) groupSize.x) + (int) groupSize.x;</b>
&nbsp;    }
<b class="fc">&nbsp;    if (wavesLeft() == 0) {</b>
<b class="fc">&nbsp;      return customersRemaining;</b>
&nbsp;    }
&nbsp;
&nbsp;    // gets the number of customer for the current wave from the list of customers per wave
<b class="fc">&nbsp;    return customersPerWave.get(currentWave - 1);</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets customers remaining.
&nbsp;   *
&nbsp;   * @return the customers remaining
&nbsp;   */
&nbsp;  public int getCustomersRemaining() {
<b class="nc">&nbsp;    return customersRemaining;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Lets a new customer group walk through the door
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   * @author Jack Vickers
&nbsp;   */
&nbsp;  void createNewCustomer() {
<b class="fc">&nbsp;    Table table = getTable();</b>
&nbsp;
<b class="fc">&nbsp;    int customerAmount = calculateCustomerAmount();</b>
<b class="fc">&nbsp;    customersRemaining -= customerAmount;</b>
&nbsp;
<b class="fc">&nbsp;    currentWaitingCustomer = new CustomerGroups(customerAmount, currentCustomer, doorTarget,</b>
<b class="fc">&nbsp;        customerFrustrationStart, menu.createNewOrder(customerAmount, Randomisation.Normalised),</b>
&nbsp;        customerAtlas);
<b class="fc">&nbsp;    currentCustomer += customerAmount;</b>
&nbsp;
<b class="fc">&nbsp;    currentWaitingCustomer.table = table;</b>
<b class="fc">&nbsp;    table.designateSeating(customerAmount, rand);</b>
&nbsp;
<b class="fc">&nbsp;    setWaitingForOrderTarget();</b>
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Makes the currently waiting customers to queue up dynamically.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  void setWaitingForOrderTarget() {
<b class="fc">&nbsp;    for (int i = 0; i &lt; currentWaitingCustomer.membersInLine.size(); i++) {</b>
<b class="fc">&nbsp;      setCustomerTarget(currentWaitingCustomer.membersInLine.get(i),</b>
<b class="fc">&nbsp;          new Vector2(0, 40 * i).add(orderAreaTarget));</b>
&nbsp;
<b class="fc">&nbsp;      currentWaitingCustomer.membersInLine.get(i).eaten = false;</b>
<b class="fc">&nbsp;      currentWaitingCustomer.membersInLine.get(i).waitingAtCounter = true;</b>
<b class="fc">&nbsp;      currentWaitingCustomer.membersInLine.get(i).hideItem();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks if a new customer can be accepted if so, add a new one in. End the game if the set
&nbsp;   * number of waves has elapsed. Set Waves to -1 for &quot;endless&quot;
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void canAcceptNewCustomer() {
<b class="fc">&nbsp;    if (doSatisfactionCheck()) {</b>
<b class="fc">&nbsp;      sittingCustomers.add(currentWaitingCustomer);</b>
<b class="fc">&nbsp;      currentWaitingCustomer = null;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (currentWaitingCustomer == null &amp;&amp; sittingCustomers.size() &lt; tables.size()) {</b>
<b class="fc">&nbsp;      if (waves != currentWave++) //if not the max number of waves increment</b>
&nbsp;      {
<b class="fc">&nbsp;        createNewCustomer();</b>
&nbsp;      } else {
<b class="fc">&nbsp;        endGame();</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * If the current customer is too frustrated then make all customers in that group leave decrement
&nbsp;   * Frustration
&nbsp;   *
&nbsp;   * @param group group to leave
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void frustrationLeave(CustomerGroups group) {
<b class="fc">&nbsp;    setCustomerGroupTarget(group, doorTarget);</b>
<b class="fc">&nbsp;    group.table.relinquish();</b>
<b class="fc">&nbsp;    currentWaitingCustomer = null;</b>
<b class="fc">&nbsp;    walkingBackCustomers.add(group);</b>
&nbsp;
<b class="fc">&nbsp;    modifyReputation(-1);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets the pathfinding target of an entire group, making them walk to the location.
&nbsp;   *
&nbsp;   * @param group  the group
&nbsp;   * @param target the target
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void setCustomerGroupTarget(CustomerGroups group, Vector2 target) {
<b class="fc">&nbsp;    for (Customer customer : group.members</b>
&nbsp;    ) {
<b class="fc">&nbsp;      setCustomerTarget(customer, target);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets an individual customers pathfinding target. Begins pathfinding
&nbsp;   *
&nbsp;   * @param customer the customer
&nbsp;   * @param target   the target
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public void setCustomerTarget(Customer customer, Vector2 target) {
<b class="fc">&nbsp;    customer.givePath(pathfinding.findPath((int) customer.gameObject.position.x,</b>
&nbsp;        (int) customer.gameObject.position.y, (int) target.x, (int) target.y,
&nbsp;        DistanceTest.Manhatten));
<b class="fc">&nbsp;    customer.foodRecipe.isVisible = false;</b>
<b class="fc">&nbsp;    customer.recipeCloseButton.isVisible = false;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Test remove customers.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  void removeCustomerTest() {
<b class="nc">&nbsp;    if (Gdx.input.isKeyJustPressed(</b>
&nbsp;        Keys.S) &amp;&amp; currentWaitingCustomer != null) {
<b class="nc">&nbsp;      Customer customer = currentWaitingCustomer.removeFirstCustomer();</b>
<b class="nc">&nbsp;      numCustomersServed += 1;</b>
<b class="nc">&nbsp;      setCustomerTarget(customer, currentWaitingCustomer.table.GetNextSeat());</b>
<b class="nc">&nbsp;      changeMoney(moneyPerCustomer);</b>
<b class="nc">&nbsp;      setWaitingForOrderTarget();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Super food upgrade.
&nbsp;   */
&nbsp;  public void superFoodUpgrade() {
<b class="fc">&nbsp;    Customer customer = currentWaitingCustomer.removeFirstCustomer();</b>
<b class="fc">&nbsp;    numCustomersServed += 1;</b>
<b class="fc">&nbsp;    setCustomerTarget(customer, currentWaitingCustomer.table.GetNextSeat());</b>
<b class="fc">&nbsp;    changeMoney(moneyPerCustomer);</b>
<b class="fc">&nbsp;    setWaitingForOrderTarget();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Remove any customer.
&nbsp;   *
&nbsp;   * @param customerToRemove the customer to remove
&nbsp;   */
&nbsp;  void removeAnyCustomer(Integer customerToRemove) {
<b class="nc">&nbsp;    Customer customer = currentWaitingCustomer.removeAnyCustomer(customerToRemove);</b>
<b class="nc">&nbsp;    if (customer != null) {</b>
<b class="nc">&nbsp;      numCustomersServed += 1;</b>
<b class="nc">&nbsp;      setCustomerTarget(customer, currentWaitingCustomer.table.GetNextSeat());</b>
<b class="nc">&nbsp;      changeMoney(moneyPerCustomer);</b>
<b class="nc">&nbsp;      setWaitingForOrderTarget();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * End the game sequence. Call upper end game sequence.
&nbsp;   *
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  private void endGame() {
&nbsp;    //calculate win or loss
&nbsp;
&nbsp;    //Calculate points
<b class="fc">&nbsp;    EndOfGameValues values = new EndOfGameValues();</b>
<b class="fc">&nbsp;    values.score = money;</b>
<b class="fc">&nbsp;    values.won = reputation &gt; 0;</b>
<b class="fc">&nbsp;    callEndGame.accept(values);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Tetris super food action boolean.
&nbsp;   *
&nbsp;   * @param dish the dish
&nbsp;   * @return the boolean
&nbsp;   */
&nbsp;  public boolean tetrisSuperFoodAction(Item dish) {
<b class="fc">&nbsp;    Boolean anyCustomer = false;</b>
<b class="fc">&nbsp;    LinkedList&lt;OrderType&gt; orderTypes = menu.getAllOrderTypes();</b>
<b class="fc">&nbsp;    List&lt;ItemEnum&gt; toClear = null;</b>
<b class="fc">&nbsp;    OrderType orderType = menu.getOrderTypeFromSuper(dish);</b>
<b class="fc">&nbsp;    toClear = orderType.orderables;</b>
<b class="fc">&nbsp;    for (int i = currentWaitingCustomer.membersInLine.size() - 1; i &gt;= 0; i--) {</b>
<b class="fc">&nbsp;      Customer current = currentWaitingCustomer.membersInLine.get(i);</b>
<b class="fc">&nbsp;      if (toClear.contains(current.getDish())) {</b>
<b class="fc">&nbsp;        setCustomerTarget(currentWaitingCustomer.membersInLine.get(i),</b>
<b class="fc">&nbsp;            currentWaitingCustomer.table.GetNextSeat());</b>
&nbsp;        //currentWaiting.MembersSeatedOrWalking.add(currentWaiting.MembersInLine.get(i));
<b class="fc">&nbsp;        currentWaitingCustomer.feedSpecificCustomer(i);</b>
<b class="fc">&nbsp;        numCustomersServed += 1;</b>
<b class="fc">&nbsp;        anyCustomer = true;</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    return anyCustomer;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Interface with the customer from the chefs via customer counters. Checks to see if the given
&nbsp;   * food is an ordered food Makes customer sit down if so
&nbsp;   *
&nbsp;   * @param item the item
&nbsp;   * @return True if accepted, otherwise false
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean tryGiveFood(Item item) {
<b class="fc">&nbsp;    if (item.name().contains(&quot;Super&quot;)) {</b>
<b class="nc">&nbsp;      return tetrisSuperFoodAction(item);</b>
&nbsp;    }
<b class="fc">&nbsp;    int success = currentWaitingCustomer.seeIfDishIsCorrect(item);</b>
&nbsp;
<b class="fc">&nbsp;    if (success != -1) {</b>
<b class="fc">&nbsp;      currentWaitingCustomer.feedSpecificCustomer(success);</b>
<b class="fc">&nbsp;      setCustomerTarget(currentWaitingCustomer.membersSeatedOrWalking.get(</b>
<b class="fc">&nbsp;              currentWaitingCustomer.membersSeatedOrWalking.size() - 1),</b>
<b class="fc">&nbsp;          currentWaitingCustomer.table.GetNextSeat());</b>
<b class="fc">&nbsp;      setWaitingForOrderTarget();</b>
<b class="fc">&nbsp;      changeMoney(moneyPerCustomer);</b>
&nbsp;    }
<b class="fc">&nbsp;    return success != -1;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Gets member seated or walking.
&nbsp;   *
&nbsp;   * @return the member seated or walking
&nbsp;   */
&nbsp;  public List&lt;Customer&gt; getMemberSeatedOrWalking() {
<b class="fc">&nbsp;    return currentWaitingCustomer.membersSeatedOrWalking;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks to see if the current customer group can be expelled from the currenly waiting slot
&nbsp;   *
&nbsp;   * @return True if so, otherwise false
&nbsp;   * @author Felix Seanor
&nbsp;   */
&nbsp;  public boolean doSatisfactionCheck() {
<b class="fc">&nbsp;    return currentWaitingCustomer != null &amp;&amp; currentWaitingCustomer.membersInLine.size() == 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Delete all customers.
&nbsp;   */
&nbsp;  public void deleteAllCustomers() {
<b class="fc">&nbsp;    if (currentWaitingCustomer != null) {</b>
<b class="nc">&nbsp;      currentWaitingCustomer.destroy();</b>
&nbsp;
&nbsp;    }
<b class="fc">&nbsp;    for (CustomerGroups group : sittingCustomers) {</b>
<b class="nc">&nbsp;      group.destroy();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    for (CustomerGroups group : walkingBackCustomers) {</b>
<b class="nc">&nbsp;      group.destroy();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    sittingCustomers.clear();</b>
<b class="fc">&nbsp;    walkingBackCustomers.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Loads the state of the game from a GameState object.
&nbsp;   *
&nbsp;   * @param state The state to load
&nbsp;   * @author Felix Seanor
&nbsp;   * @author Jack Vickers
&nbsp;   */
&nbsp;  public void loadState(GameState state) {
&nbsp;    //Wave State
<b class="fc">&nbsp;    currentWave = state.wave;</b>
<b class="fc">&nbsp;    waves = state.maxWave;</b>
<b class="fc">&nbsp;    groupSize = state.groupSize;</b>
&nbsp;    //Reputation
<b class="fc">&nbsp;    reputation = state.reputation;</b>
<b class="fc">&nbsp;    maxReputation = state.maxReputation;</b>
<b class="fc">&nbsp;    customerFrustrationStart = state.maxFrustration;</b>
&nbsp;    //Money
<b class="fc">&nbsp;    maxMoney = state.maxMoney;</b>
<b class="fc">&nbsp;    money = state.money;</b>
&nbsp;
<b class="fc">&nbsp;    customersPerWave = state.customersPerWave;</b>
<b class="fc">&nbsp;    if (!Objects.isNull(customersPerWave)) { // if this is not null, a scenario game is being loaded</b>
<b class="nc">&nbsp;      if (customersPerWave.size() &gt; 0) { // this is true for the scenario mode</b>
<b class="nc">&nbsp;        customersRemaining = 0;</b>
&nbsp;      }
&nbsp;      // correctly calculates the number of customers remaining (scenario mode)
<b class="nc">&nbsp;      for (int i = currentWave; i &lt; customersPerWave.size(); i++) {</b>
<b class="nc">&nbsp;        customersRemaining += customersPerWave.get(i);</b>
&nbsp;      }
&nbsp;    }
<b class="fc">&nbsp;    deleteAllCustomers();</b>
&nbsp;
<b class="fc">&nbsp;    if (state.customerGroupStates[0] != null) {</b>
<b class="fc">&nbsp;      currentWaitingCustomer = new CustomerGroups(state.customerGroupStates[0], customerAtlas);</b>
<b class="fc">&nbsp;      Table table = tables.get(state.customerGroupStates[0].table);</b>
<b class="fc">&nbsp;      table.designateSeating(state.customerGroupStates[0].customerPositions.length, rand);</b>
<b class="fc">&nbsp;      currentWaitingCustomer.table = table;</b>
&nbsp;
&nbsp;      // if there are customers walking to the table
<b class="fc">&nbsp;      if (state.customerGroupStates[0].numCustomersWalkingToTable &gt; 0) {</b>
<b class="nc">&nbsp;        for (Customer cust : currentWaitingCustomer.members) {</b>
&nbsp;          // If the customer is not at the order point and is not at the entrance (therefore is moving towards a table)
<b class="nc">&nbsp;          if ((cust.getX() &gt; 360.0f || cust.getX() &lt; 360.0f) &amp;&amp; (cust.getX() != 200</b>
<b class="nc">&nbsp;              &amp;&amp; cust.getY() != 100)) {</b>
<b class="nc">&nbsp;            setCustomerTarget(cust,</b>
<b class="nc">&nbsp;                currentWaitingCustomer.table.GetNextSeat()); // set the customer to walk to the table</b>
<b class="nc">&nbsp;            currentWaitingCustomer.membersInLine.remove(cust); // remove the customer from the line</b>
&nbsp;          } else {
<b class="nc">&nbsp;            cust.eaten = false;</b>
<b class="nc">&nbsp;            cust.waitingAtCounter = true;</b>
<b class="nc">&nbsp;            cust.hideItem();</b>
&nbsp;          }
<b class="nc">&nbsp;        }</b>
&nbsp;      }
&nbsp;
&nbsp;      // set the target of the customers who should be in line to the order point
<b class="fc">&nbsp;      setWaitingForOrderTarget();</b>
&nbsp;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    int i = 0;</b>
<b class="fc">&nbsp;    for (CustomerGroupState groupState : state.customerGroupStates</b>
&nbsp;    ) {
<b class="fc">&nbsp;      if (i == 0) {</b>
<b class="fc">&nbsp;        i++;</b>
<b class="fc">&nbsp;        continue;</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      CustomerGroups customerGroups = new CustomerGroups(groupState, customerAtlas);</b>
&nbsp;
<b class="fc">&nbsp;      Table table = tables.get(state.customerGroupStates[i].table);</b>
<b class="fc">&nbsp;      if (groupState.leaving) { // customers are leaving</b>
<b class="nc">&nbsp;        setCustomerGroupTarget(customerGroups, doorTarget);</b>
<b class="nc">&nbsp;        walkingBackCustomers.add(customerGroups);</b>
&nbsp;      } else { // customers are/ should be sitting
<b class="fc">&nbsp;        customerGroups.table = table;</b>
<b class="fc">&nbsp;        table.designateSeating(state.customerGroupStates[i].customerPositions.length, rand);</b>
&nbsp;
&nbsp;        // ensures that a table target is set for these customers
<b class="fc">&nbsp;        for (Customer cust : customerGroups.members) {</b>
<b class="fc">&nbsp;          setCustomerTarget(cust, table.GetNextSeat());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        sittingCustomers.add(customerGroups);</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      i++;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Save state.
&nbsp;   *
&nbsp;   * @param state the state
&nbsp;   */
&nbsp;  public void saveState(GameState state) {
<b class="fc">&nbsp;    state.wave = currentWave;</b>
&nbsp;
&nbsp;    // List of number of customers per wave
<b class="fc">&nbsp;    state.customersPerWave = customersPerWave;</b>
&nbsp;
<b class="fc">&nbsp;    state.maxWave = waves;</b>
<b class="fc">&nbsp;    state.groupSize = groupSize;</b>
&nbsp;    //Reputation
<b class="fc">&nbsp;    state.reputation = reputation;</b>
<b class="fc">&nbsp;    state.maxReputation = maxReputation;</b>
<b class="fc">&nbsp;    state.maxFrustration = customerFrustrationStart;</b>
&nbsp;    //Money
<b class="fc">&nbsp;    state.maxMoney = maxMoney;</b>
<b class="fc">&nbsp;    state.money = money;</b>
&nbsp;
&nbsp;    //Customers
&nbsp;
<b class="fc">&nbsp;    List&lt;CustomerGroupState&gt; savedGroups = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;    if (currentWaitingCustomer == null) {</b>
<b class="fc">&nbsp;      savedGroups.add(null);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      savedGroups.add(currentWaitingCustomer.saveState(false)); // customer groups that are waiting</b>
&nbsp;
&nbsp;    }
<b class="fc">&nbsp;    for (CustomerGroups group : sittingCustomers) { // customer groups that are sitting</b>
<b class="fc">&nbsp;      savedGroups.add(group.saveState(false));</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    for (CustomerGroups group : walkingBackCustomers) { // customer groups that are leaving</b>
<b class="nc">&nbsp;      if (group.members.size() &gt; 0) {</b>
<b class="nc">&nbsp;        savedGroups.add(group.saveState(true));</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
<b class="fc">&nbsp;    state.customerGroupStates = savedGroups.toArray(new CustomerGroupState[0]);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Leaving customer count int.
&nbsp;   *
&nbsp;   * @return the int
&nbsp;   */
&nbsp;  public int leavingCustomerCount() {
<b class="fc">&nbsp;    return walkingBackCustomers.size();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Sets money.
&nbsp;   *
&nbsp;   * @param i the
&nbsp;   */
&nbsp;  public void setMoney(int i) {
<b class="nc">&nbsp;    money = i;</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-03 02:34</div>
</div>
</body>
</html>
